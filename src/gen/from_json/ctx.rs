//! Wrapper module for the tree-generation context [`GenCtx`]

use super::config::{
    BaseGenerationConfig, ChildInheritConfig, GenerationConfig, GeneratorNode, ManualSettings,
};
use crate::gen::Point;
use crate::{float, ChildDirection, Float};
use std::cell::Cell;
use std::rc::Rc;

#[derive(Copy, Clone)]
pub struct BranchSize {
    pub length: Float,
    pub nominal_radius: Float,
    pub abnormal_radius: Float,
}

/// Context for generating a single branch, extendable to its children
pub struct GenCtx<'cfg> {
    // `ctx_parent` is not the *direct* parent, but the next change in configuration
    ctx_parent: Parent<'cfg>,

    // The node in the configuration for this branch, if it was specified up to the current branch
    // being generated
    config_node: Option<&'cfg GeneratorNode>,

    // The size of the parent branch.
    //
    // There's actually a special case here for the root branch; because it has no parent, we
    // redirect getting the size of any branch at depth=1 (only the root) to draw directly from
    // this field.
    parent_size: BranchSize,

    angle_from_parent: Float,
    total_angle: Float,

    this_branch: Cell<Option<BranchSize>>,
    end_pos: Cell<Option<Point>>,

    parent_end_pos: Point,

    // The depth of the node generated by this conext
    depth: usize,
}

#[derive(Clone)]
enum Parent<'cfg> {
    Base(&'cfg BaseGenerationConfig),
    Override(Rc<GenCtx<'cfg>>, Option<ChildDirection>),
}

impl ChildDirection {
    fn pick<T>(&self, left: T, right: T) -> T {
        match self {
            Self::Left => left,
            Self::Right => right,
        }
    }
}

impl<'cfg> GenCtx<'cfg> {
    /// Creates a `GenCtx` for the root branch
    pub fn root(
        root: &'cfg GeneratorNode,
        cfg: &'cfg BaseGenerationConfig,
        initial_branch: BranchSize,
        start_pos: Point,
    ) -> Rc<Self> {
        Rc::new(GenCtx {
            ctx_parent: Parent::Base(cfg),
            config_node: Some(root),
            parent_size: initial_branch,
            angle_from_parent: 0.0,
            total_angle: -float::FRAC_PI_2,
            this_branch: Cell::new(None),
            end_pos: Cell::new(None),
            parent_end_pos: start_pos,
            depth: 1,
        })
    }

    /// Returns the depth of the branch generated by this context
    ///
    /// The root branch has depth 1.
    pub fn depth(&self) -> usize {
        self.depth
    }

    /// Returns the offset of this branch's angle from its parent
    pub fn angle_from_parent(&self) -> Float {
        self.angle_from_parent
    }

    /// Returns the position of the end of this branch, relative to the start of the root (i.e. at
    /// the fork to children, or the start of the acinar region)
    pub fn end_pos(self: &Rc<Self>) -> Point {
        if let Some(p) = self.end_pos.get() {
            return p;
        }

        let len = self.branch_size().length;
        let start = self.parent_end_pos;
        let angle = self.total_angle;

        let p = Point {
            x: start.x + len * angle.cos(),
            y: start.y + len * angle.sin(),
        };
        self.end_pos.set(Some(p));
        p
    }

    /// True if the context indicates that this branch should be an acinar region
    pub fn is_acinar(self: &Rc<Self>) -> bool {
        let max_depth = self.effective_max_depth();

        assert!(self.depth <= max_depth);
        self.depth == max_depth
    }

    /// Returns the size of the branch generated in this context
    ///
    /// Calls to this function are cached; calling it more than once on the same `GenCtx` is free.
    pub fn branch_size(self: &Rc<Self>) -> BranchSize {
        if let Some(bs) = self.this_branch.get() {
            return bs;
        }

        let mut bs = self.calculate_branch_scaling();
        bs.length *= self.parent_size.length;
        bs.nominal_radius *= self.parent_size.nominal_radius;
        bs.abnormal_radius *= self.parent_size.abnormal_radius;

        self.this_branch.set(Some(bs));
        bs
    }

    /// Returns the "nominal" and "abnormal" compliance multipliers, assuming that this is an
    /// acinar region
    pub fn compliance(self: &Rc<Self>) -> (Float, Float) {
        let (mut nominal, mut abnormal) = (None, None);

        let mut parent = Parent::Override(self.clone(), None);
        loop {
            if let (Some(n), Some(a)) = (nominal, abnormal) {
                return (n, a);
            }

            let (ctx, dir) = match parent {
                // base configuration doesn't have a relevant field
                Parent::Base(_) => return (nominal.unwrap_or(1.0), abnormal.unwrap_or(1.0)),
                Parent::Override(c, d) => (c, d),
            };

            match ctx.config_node.and_then(|n| Self::extract_config(n, dir)) {
                None | Some(ConfigRef::Manual(_)) => (),
                Some(ConfigRef::Auto(cfg)) => {
                    if let Some(c) = &cfg.relative_compliance {
                        nominal = nominal.or(c.nominal);
                        abnormal = abnormal.or(c.abnormal);
                    }
                }
            }

            parent = ctx.ctx_parent.clone();
        }
    }

    /// Creates the `GenCtx`s corresponding to the left and right child of this branch,
    /// respectively
    pub fn children(self: &Rc<Self>) -> (Rc<Self>, Rc<Self>) {
        if self.depth == super::MAX_DEPTH {
            panic!("internal maximum depth limit exceeded. Your calculation would be inaccurate anyways.");
        }

        use ChildDirection::{Left, Right};

        let (left_config_node, right_config_node) = match self.config_node {
            Some(GeneratorNode::Manual { left, right, .. }) => (left.as_deref(), right.as_deref()),
            _ => (None, None),
        };

        let (left_angle, right_angle) = self.calculate_child_angles();

        let left = GenCtx {
            ctx_parent: self
                .config_node
                .and_then(|n| Self::extract_config(n, Some(Left)))
                .map(|_| Parent::Override(self.clone(), Some(Left)))
                .unwrap_or_else(|| self.ctx_parent.clone()),
            config_node: left_config_node,
            parent_size: self.branch_size(),
            angle_from_parent: left_angle,
            total_angle: self.total_angle + left_angle,
            this_branch: Cell::new(None),
            end_pos: Cell::new(None),
            parent_end_pos: self.end_pos(),
            depth: self.depth + 1,
        };

        let right = GenCtx {
            ctx_parent: self
                .config_node
                .and_then(|n| Self::extract_config(n, Some(Right)))
                .map(|_| Parent::Override(self.clone(), Some(Right)))
                .unwrap_or_else(|| self.ctx_parent.clone()),
            config_node: right_config_node,
            parent_size: self.branch_size(),
            angle_from_parent: right_angle,
            total_angle: self.total_angle + right_angle,
            this_branch: Cell::new(None),
            end_pos: Cell::new(None),
            parent_end_pos: self.end_pos(),
            depth: self.depth + 1,
        };

        (Rc::new(left), Rc::new(right))
    }
}

enum ConfigRef<'cfg> {
    Auto(&'cfg GenerationConfig),
    Manual(&'cfg ManualSettings),
}

impl<'cfg> GenCtx<'cfg> {
    fn extract_config(
        node: &'cfg GeneratorNode,
        dir: Option<ChildDirection>,
    ) -> Option<ConfigRef<'cfg>> {
        use ChildDirection::{Left, Right};
        use GeneratorNode::{Auto, Manual};

        match (node, dir) {
            (Auto(cfg), _) => cfg.as_ref().map(ConfigRef::Auto),
            (Manual { left_override, .. }, Some(Left)) => {
                left_override.as_ref().map(ConfigRef::Manual)
            }
            (Manual { right_override, .. }, Some(Right)) => {
                right_override.as_ref().map(ConfigRef::Manual)
            }
            _ => None,
        }
    }

    /// Returns the maximum depth affecting this branch and all its descendents
    fn effective_max_depth(self: &Rc<Self>) -> usize {
        let mut parent = Parent::Override(self.clone(), None);

        loop {
            let (ctx, dir) = match parent {
                Parent::Base(cfg) => return cfg.max_depth.get(),
                Parent::Override(c, d) => (c, d),
            };

            let cfg_ref = ctx.config_node.and_then(|n| Self::extract_config(n, dir));

            if let Some(ConfigRef::Auto(cfg)) = cfg_ref {
                if let Some(d) = cfg.max_depth {
                    return d + ctx.depth;
                }
            }

            parent = ctx.ctx_parent.clone();
        }
    }

    /// Performs the actual search required by the `branch_size` method.
    fn calculate_branch_scaling(self: &Rc<Self>) -> BranchSize {
        let mut length = None;
        let mut nominal = None;
        let mut abnormal = None;

        let mut parent = Parent::Override(self.clone(), None);

        loop {
            if let (Some(l), Some(n), Some(a)) = (length, nominal, abnormal) {
                return BranchSize {
                    length: l,
                    nominal_radius: n,
                    abnormal_radius: a,
                };
            }

            let (ctx, dir) = match parent {
                Parent::Base(cfg) => {
                    return BranchSize {
                        length: length.unwrap_or(cfg.branch_length_decrease),
                        nominal_radius: nominal.unwrap_or(cfg.branch_radius_decrease),
                        abnormal_radius: abnormal.unwrap_or(cfg.branch_radius_decrease),
                    }
                }
                Parent::Override(c, d) => (c, d),
            };

            match ctx.config_node.and_then(|n| Self::extract_config(n, dir)) {
                // The manual configuration only applies to direct children
                Some(ConfigRef::Manual(cfg)) if ctx.depth + 1 == self.depth => {
                    length = length.or(cfg.relative_length);
                    nominal = nominal.or(cfg.relative_radius_nominal);
                    abnormal = abnormal.or(cfg.relative_radius_abnormal);
                }
                // But auto-configuration applies to all descendents
                Some(ConfigRef::Auto(cfg)) => {
                    let unpack = |(l, r, inherit_cfg): &(
                        Option<Float>,
                        Option<Float>,
                        ChildInheritConfig,
                    )|
                     -> Option<Float> {
                        if matches!(inherit_cfg.reset_after, Some(n) if n.get() + ctx.depth < self.depth)
                        {
                            return None;
                        }

                        dir.map(|d| d.pick(l, r))
                            .or_else(|| (l == r).then(|| Some(l))?)
                            .map(|x| *x)
                            .unwrap_or(None)
                    };

                    length = length.or_else(|| {
                        cfg.branch_length_decrease
                            .as_ref()
                            .and_then(|tup| unpack(tup))
                    });

                    if nominal.is_none() || abnormal.is_none() {
                        let radius = cfg
                            .branch_radius_decrease
                            .as_ref()
                            .and_then(|tup| unpack(tup));

                        nominal = nominal.or(radius);
                        abnormal = abnormal.or(radius);
                    }
                }
                _ => (),
            }

            parent = ctx.ctx_parent.clone();
        }
    }

    /// Calculates the relative angles of the left and right child, respectively
    ///
    /// Note: The angles are signed properly, so that the left angle is negative and the right is
    /// positive (provided that the input is positive).
    fn calculate_child_angles(self: &Rc<Self>) -> (Float, Float) {
        let (mut left, mut right) = (None, None);

        match self.config_node {
            Some(GeneratorNode::Manual {
                left_override,
                right_override,
                ..
            }) => {
                left = left_override.as_ref().and_then(|s| s.relative_angle);
                right = right_override.as_ref().and_then(|s| s.relative_angle);
            }
            _ => (),
        }

        if let (Some(l), Some(r)) = (left, right) {
            return (-l, r);
        }

        let mut parent = Parent::Override(self.clone(), None);

        let (default_left, default_right) = loop {
            let (ctx, dir) = match parent {
                Parent::Base(cfg) => break (cfg.split_angle, cfg.split_angle),
                Parent::Override(c, d) => (c, d),
            };

            let cfg_ref = ctx.config_node.and_then(|n| Self::extract_config(n, dir));

            match cfg_ref {
                Some(ConfigRef::Auto(&GenerationConfig {
                    child_angles: Some((l, r, ref inherit)),
                    ..
                })) if matches!(inherit.reset_after, Some(n) if n.get() + ctx.depth > self.depth) =>
                {
                    break (l, r);
                }
                _ => (),
            }

            parent = ctx.ctx_parent.clone();
        };

        (
            -left.unwrap_or(default_left),
            right.unwrap_or(default_right),
        )
    }
}
